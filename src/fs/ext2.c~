#include <fs/ext2.h>

struct inode root_inode;

static struct ext2_extended_superblock ext2_sb;

static uint32_t block_size;
static uint32_t fragment_size;
static uint32_t inode_count;
static uint32_t block_count;
static uint32_t blocks_per_group;
static uint32_t inodes_per_group;
static uint32_t block_group_count;
static uint32_t bgd_addr;
static uint32_t inode_size;
static uint32_t inodes_per_block;
static uint8_t  dir_has_typefield;

static struct file_system_type *ext2_fs_type;
static device_t *ext2_dev;

static ext2_buffer_t buffer[MAX_BUFFERS];
static size_t buffer_index;

static struct super_block *super_block;

struct file_operations ext2_file_ops = {0, ext2_read, 0, 0};
struct inode_operations ext2_inode_ops = {&ext2_file_ops,0,0,0,0,0,0,0,
					  0,0,0,0,0,0,0,0};
struct super_operations ext2_super_operations = {ext2_read_inode, 0,0,0,0,0};

void ext2_parse_superblock(ext2_extended_superblock_t *dest, device_t *dev)
{
	ata_read_sects_28_pio(dest, 2, dev, SUPERBLOCK_ADDR);

	if (dest->base_sb.ext2_signature != 0xEF53)
		kpanic("not ext2");

	block_size = 0x400 << dest->base_sb.block_size;
	fragment_size = 0x400 << dest->base_sb.fragment_size;
	inode_count = dest->base_sb.inode_count;
	block_count = dest->base_sb.block_count;
	blocks_per_group = dest->base_sb.blocks_per_group;
	inodes_per_group = dest->base_sb.inodes_per_group;

        block_group_count = CEILING_DIV(block_count, blocks_per_group);
	
	bgd_addr = (block_size == 0x400) ? 2 : 1;

	if (dest->base_sb.major_version >= 1)
	        inode_size = dest->inode_size;
	else
		inode_size = 128;

	inodes_per_block = block_size / inode_size;

	dir_has_typefield = (dest->required_features & DIR_ENTRY_HAS_TYPEFIELD) ? true : false;

	read_bgd_table(dev);
}

void read_inode(ext2_inode_t *dest, uint32_t inode, device_t *dev)
{
	const uint32_t inode_block_group = BG_OF_INODE(inode);
	terminal_writestring("Reading inode");


	//read_bgd_table(&bgdt_entry, inode_block_group, dev);

	const uint32_t index = INODE_INDEX(inode);
	const uint32_t block_of_inode = bgdt_entries[inode_block_group].inode_table + BLOCK_OF_INODE(index);

	//uint8_t *tmp_buff = (uint8_t*)kmalloc(512);
	uint8_t tmp_buff[512];

	ata_read_sects_28_pio(tmp_buff, 1, dev, ADDR_OF_BLOCK(block_of_inode));


	for (uint8_t i = 0; i < sizeof(ext2_inode_t); i++)
	{
		//*((uint8_t*)dest + i) = tmp_buff[i + 2 * sizeof(inode_t) /* ((index - 1) % inodes_per_block))*/];
		*((uint8_t*)dest + i) = tmp_buff[i + (inode_size * ((index) % inodes_per_block))];
	}

}



void read_bgd_table(device_t *dev)
{
	bgdt_entries = (ext2_bgd_t*)kmalloc(512);
	ata_read_sects_28_pio(bgdt_entries, 1, dev, ADDR_OF_BLOCK(bgd_addr));
}


void ext2_list_directory(ext2_inode_t *dir, device_t *dev)
{
	terminal_writestring("in list_directory\n");

	char tmp_buff[512];
	ext2_directory_entry_t *dir_entry;
	
	for (uint8_t i = 0; i < 12; i++)
	{
		if (dir->direct_block[i] == 0)
			break;
		ata_read_sects_28_pio(tmp_buff, 1, dev, ADDR_OF_BLOCK(dir->direct_block[i]));
		dir_entry = (ext2_directory_entry_t*)tmp_buff;

		while (((uint8_t*)dir_entry) + dir_entry->entry_size < tmp_buff + 512)
		{
			if (dir_entry->inode != SKIP_DIR)
			{
				terminal_writestring("Directory entry name: ");
				uint16_t name_len = (dir_has_typefield) ?
					dir_entry->name_length : dir_entry->name_length |
					((uint16_t)dir_entry->type) << 8;

				uint8_t *c = ((uint8_t*)dir_entry) + 8;
				for (uint16_t j = 0; j < name_len; j++, c++)
				{
					terminal_putchar(*c);
				}
				terminal_putchar('\n');
				terminal_writestring("Directory entry inode number: ");
				terminal_printhex32(dir_entry->inode);
				terminal_putchar('\n');
				if (dir_has_typefield)
				{
					terminal_writestring("directory entry type: ");
					terminal_printhex(dir_entry->type);
					terminal_putchar('\n');
				}
			}
			terminal_writestring("size");
			terminal_printhex32(dir_entry->entry_size);

			dir_entry = dir_entry->entry_size + ((uint8_t*)dir_entry);
		}
	}
}


void read_file(ext2_inode_t *file, device_t *dev)
{
	terminal_writestring("In read_file\n");
	if (file->type_permissions & 0xF000 != TYPE_REG_FILE)
		kpanic("not a file");

	char tmp_buff[512];

	for (uint8_t i = 0; i < 12; i++)
	{
		terminal_writestring("direct block: ");
		terminal_printhex32(file->direct_block[i]);
		if (i * 512 >= file->size_low || file->direct_block[i] == 0 || file->direct_block[i] >= block_count)
			break;
		ata_read_sects_28_pio(tmp_buff, 1, dev, ADDR_OF_BLOCK(file->direct_block[i]));

		terminal_writestring(tmp_buff);
	}
}

size_t write_file(void *ptr, size_t size, size_t nmemb, ext2_inode_t *file, uint32_t inode, device_t *dev)
{
	terminal_writestring("In write file\n");
	if (file->type_permissions & 0xF000 != TYPE_REG_FILE)
		kpanic("not a file");

	
	char tmp_buff[512];

	size_t i = 0;
	while (i < nmemb * size)
	{
		memset(tmp_buff, 0, 512);
		const uint32_t count = (nmemb * size - i);
		memcpy(tmp_buff, (uint8_t*)ptr + i, (count >= 512) ? 512 : count);
		ata_write_sects_28_pio(tmp_buff, 1, dev, ADDR_OF_BLOCK(file->direct_block[i / 512]));		
		if (i + 512 >= 0x1800 || file->direct_block[i / 512] >= block_count)
		{
			//change_file_size(inode, dev, i);
			return i / size;
		}
		i += 512;
	}
	//change_file_size(inode, dev, nmemb * size);
	return nmemb;
}

static void change_file_size(uint32_t inode, device_t *dev, int32_t size)
{
	const uint32_t inode_block_group = BG_OF_INODE(inode);
	terminal_writestring("Reading inode");

	const uint32_t index = INODE_INDEX(inode);
	const uint32_t block_of_inode = bgdt_entries[inode_block_group].inode_table + BLOCK_OF_INODE(index);

	char tmp_buff[512];

	ata_read_sects_28_pio(tmp_buff, 1, dev, ADDR_OF_BLOCK(block_of_inode));

	ext2_inode_t *tmp_inode = tmp_buff + INODE_BLOCK_OFF(index);
	tmp_inode->size_low = size;
	terminal_putchar('\n');
	terminal_printhex32(tmp_inode->size_low);
	for(;;);
	ata_write_sects_28_pio(tmp_buff, 1, dev, ADDR_OF_BLOCK(block_of_inode));
}


uint32_t alloc_inode(device_t *dev)
{
	uint32_t free_inode;
	size_t i;
	for (i = 0; i < block_group_count && free_inode == 0; i++)
	{
		if (/*descriptor->free_block_count == 0 || */bgdt_entries[i].free_inode_count == 0)
		{
			continue;
		}

		char tmp_buff[512];

		//uint32_t free_block;
		

		/*for (free_block = 0; free_block < blocks_per_group; free_block++)
		  {
		  if ((free_block * sizeof(bgd_t)) % 512 == 0)
		  ata_read_sects_28_pio(tmp_buff, 1, dev,
		  descriptor->block_usage_bitmap +
		  (free_block * sizeof(bgd_t)) / 512);
		  if (tmp_buff[free_block/512] >> (free_block % 512) == 0)
		  {
		  tmp_buff[free_block/512] |= 1 << free_block % 512;
		  ata_write_sects_28_pio(tmp_buff, 1, dev, descriptor->block_usage_bitmap +
		  (free_block * sizeof(bgd_t)) / 512);
		  }
		  }*/

		for (free_inode = 0; free_inode < inodes_per_group; free_inode++)
		{
			if ((free_inode * sizeof(ext2_bgd_t)) % 512 == 0)
				ata_read_sects_28_pio(tmp_buff, 1, dev,
						      bgdt_entries[i].inode_usage_bitmap +
						      (free_inode * sizeof(ext2_bgd_t)) / 512);
			if (tmp_buff[free_inode/512] >> (free_inode % 512) == 0)
			{
				tmp_buff[free_inode/512] |= 1 << free_inode % 512;
				ata_write_sects_28_pio(tmp_buff, 1, dev, bgdt_entries[i].inode_usage_bitmap +
						       (free_inode * sizeof(ext2_bgd_t)) / 512);
			}
		}
	}

	//free_block += blocks_per_group * block_group;
	free_inode += inodes_per_group * (i + 1);

	//inode_t *inode = (inode_t*)kmalloc(sizeof(inode_t));
	return free_inode;
}

ssize_t ext2_read(struct file *filep, char *buff, size_t count, size_t *off)
{
	terminal_writestring("in ext2_read");

	struct inode *inode = filep->f_inode;

	if (strcmp(inode->i_sb->fs_type->name, ext2_fs_type->name) != 0)
	{
		kpanic("ext2_read. wrong filesystem");
	}
	if (*off + count >= inode->size)
	{
		return -1;
	}
	if (inode->flags & 0xF000 != TYPE_REG_FILE)
	{
		return -1;
	}
	ssize_t ret = 0;
	const uint32_t sect_count = CEILING_DIV(count, 512) * 512;
        uint8_t *tmp_buff = (uint8_t*)kmalloc(sect_count + 1);
	for (size_t i = *off / 512; i < 12 && inode->ext2_blocks[i] != 0; i++)
	{
		ext2_buffer_t *ptr = find_buffer(inode->ext2_blocks[i]);
		memcpy(tmp_buff + ret, ptr->buff, (ret + 512 > count) ? (count - ret) : 512);
		if (ret + 512 > count)
		{
			ret = count;
			goto exit;
		}
		else
			ret += 512;
	}

exit:
	memcpy(buff, tmp_buff + (*off % 512), ret + (*off % 512));
	kfree(tmp_buff);
	return ret;
}

void ext2_read_inode(struct inode *dest)
{
	terminal_writestring("in read inode");
	dest->i_ops = &ext2_inode_ops;
	dest->i_sb = &super_block;
	if (dest->i_no != 0)
	{
		ext2_inode_t *tmp_inode = (ext2_inode_t*)kmalloc(sizeof(ext2_inode_t));
		dest->size = tmp_inode->size_low;
		dest->gid = tmp_inode->gid;
		dest->uid = tmp_inode->uid;
		dest->ext2_blocks = tmp_inode->direct_block;
		kfree(tmp_inode);
	}
}

struct super_block *ext2_read_super(struct super_block *sb, device_t *dev)
{
	ext2_parse_superblock(&ext2_sb, dev);
	ext2_inode_t tmp;
	read_inode(&tmp, 2, dev);
	struct inode *root = (struct inode*)kmalloc(sizeof(struct inode));
	root->i_no = 2;
	root->size = tmp.size_low;
	root->gid = tmp.gid;
	root->uid = tmp.uid;
	root->flags = tmp.flags;
	sb->root = root;
	sb->sb_ops = &ext2_super_operations;
	if (root_inode.i_no == 0)
	{
		/* mount this fs as root*/
		sb->mount_point = root;
	}
	else
		kpanic("in ext2_read_super. Unsuported");
	if (sb->fs_type == 0)
	{
		sb->fs_type = *find_file_system("ext2", 4);
	}
	ext2_fs_type = sb->fs_type;
	sb->dev = dev;
	ext2_dev = dev;
	super_block = sb;
}

static ext2_buffer_t *find_buffer(uint32_t block_num)
{
	if (block_num >= block_count)
		return 0;
        for (size_t i = 0; i < MAX_BUFFERS; i++)
	{
		if (buffer[i].block_num == block_num)
		{
			if (buffer[i].modified == true)
			{
				ata_read_sects_28_pio(buffer[i].buff, 1, ext2_dev, ADDR_OF_BLOCK(block_num));
				buffer[i].modified = false;
			}
			return buffer + i;
		}
	}
	const uint32_t new_buff = (buffer_index % MAX_BUFFERS) - 1;
	buffer[new_buff].block_num = block_num;
	buffer[new_buff].modified = false;
	ata_read_sects_28_pio(buffer[new_buff].buff, 1, ext2_dev, ADDR_OF_BLOCK(block_num));
	buffer_index++;
	return buffer + new_buff;
}
